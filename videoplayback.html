<script> let urlSearchParams = new URLSearchParams(window.location.search);
// special thanks to rehike for the signatureCipher and n decoding function
            // Get the value of the "expire" parameter
            let expireTimestamp = urlSearchParams.get("expire");
            let video_id = urlSearchParams.get("id");
            let ei = urlSearchParams.get('ei');
            let itag = urlSearchParams.get('itag');
            let host = urlSearchParams.get('host');
            let source = urlSearchParams.get('source');
            let proxy = urlSearchParams.get('proxy');
            console.log({
                expireTimestamp,
                video_id,
                ei,
                itag,
                host,
                source,
                proxy,
            });

            function isTimestampInFuture(timestamp) {
                const currentTimestamp = Math.floor(Date.now() / 1000);
                return timestamp > currentTimestamp;
            }
            // Check if the expire timestamp is in the future
            if (expireTimestamp !== null) {
                const expireTimestampNumber = parseInt(expireTimestamp, 10);
                if (isTimestampInFuture(expireTimestampNumber)) {


                    function fetchContentAndAssign(url, variableName) {
                        var DEBUG = false;

                        // Base result.
                        var result = {
                            status: "FAILURE",
                            reason: "No reason provided.",
                            content: null
                        };

                        if (DEBUG)
                            console.log("[FetchContent] Fetching content from:", url);

                        try {
                            // Use the fetch API to get content from the specified URL.
                            var xhr = new XMLHttpRequest();
                            xhr.open('GET', url, false); // Make the request synchronous
                            xhr.send();

                            if (xhr.status >= 200 && xhr.status < 300) {
                                var data = xhr.responseText;

                                result.content = data;
                                result.status = "SUCCESS";
                                if (DEBUG)
                                    console.log("[FetchContent] Content fetched successfully:", result.content);

                                // Assign the fetched content to the specified variable.
                                window[variableName] = result.content;

                                return result;
                            } else {
                                throw new Error('Network response was not ok');
                            }
                        } catch (error) {
                            result.reason = "Failed to fetch content: " + error.message;
                            console.error("[FetchContent]" + result.reason);
                            throw result;
                        }
                    }

                    var foundScriptSrc = null;

                    function makeRequest(url) {
                        return new Promise(function(resolve, reject) {
                            // Create an XHR object
                            var xhr = new XMLHttpRequest();

                            // Set up the request
                            xhr.open('GET', url, true);

                            // Define a callback function to handle the response
                            xhr.onload = function() {
                                if (xhr.status >= 200 && xhr.status < 300) {
                                    // Step 5: Update the specific element's content with the received video 
                                    var responseText = xhr.responseText;

                                    // Use regular expression to find script tag with src ending with "base.js"
                                    var scriptRegex = /<script.*?src=["'](.*?base\.js)["'].*?<\/script>/i;
                                    var match = responseText.match(scriptRegex);

                                    if (match) {
                                        foundScriptSrc = match[1];
                                        console.log('Found script with src ending with "base.js":', foundScriptSrc);
                                        resolve(foundScriptSrc);
                                    } else {
                                        console.log('No script found with src ending with "base.js"');
                                        resolve(null);
                                    }
                                } else {
                                    console.error('Request failed with status:', xhr.status);
                                    reject('Network error occurred');
                                }
                            };

                            // Handle network errors
                            xhr.onerror = function() {
                                reject('Network error occurred');
                            };

                            // Send the request
                            xhr.send();
                        });
                    }

                    // Make the XHR request
                    makeRequest('https://www.youtube.com/watch?v=Zi_XLOBDo_Y')
                        .then(function(data) {
                            console.log(data);

                            // Rest of your code continues here
                            console.log('Result from XHR:', foundScriptSrc);

                            // Example usage:
                            fetchContentAndAssign('https://www.youtube.com' + foundScriptSrc, 'playerScript');

                            function CreateUrl(format) {


                                function getDecryptorForPlayerSig(playerScript) {
                                    var DEBUG = false;

                                    if (DEBUG)
                                        console.log("[SigDecode] Using player script:", playerScript);

                                    // Resulting groups:
                                    //   [0]: Entire function declaration
                                    //   [1]: Arguments only
                                    //   [2]: Body only
                                    //   [3]: Decode calls only
                                    var DECODER_PATTERN =
                                        "function\\((.*?)\\){(a=a\\.split\\(\\\"\\\"\\);(.*?)return a\\.join\\(\\\"\\\"\\))}";

                                    // Base result.
                                    var result = {
                                        status: "FAILURE",
                                        reason: "No reason provided.",
                                        extractCb: null,
                                        cacheParams: null
                                    };

                                    var decoderMatches = playerScript.match(new RegExp(DECODER_PATTERN));
                                    if (DEBUG)
                                        console.log("[SigDecode] decoderMatches ==", decoderMatches);

                                    if (!decoderMatches) {
                                        result.reason = "Failed to extract decode function.";
                                        console.error("[Rehike.SigDecode]" + result.reason);
                                        return result;
                                    }

                                    var sourceDeclaration = decoderMatches[0];
                                    var sourceArguments = decoderMatches[1].split(",");
                                    var sourceBody = decoderMatches[2].split(";");
                                    var sourceCalls = decoderMatches[3].split(";");

                                    var lookupList = [];

                                    // Parse the source function body:
                                    for (var i = 0, j = sourceBody.length; i < j; i++) {
                                        // See if a foreign variable is being used for assignment,
                                        // and add it to the lookup list if so.
                                        var varName = sourceBody[i].split(".")[0].split("=")[0].split(",")[0];
                                        if (DEBUG)
                                            console.log("[SigDecode.ForeignIterator] Iterating #" + i + " (" + varName + ").");
                                        if (
                                            varName != sourceBody[i] &&
                                            (varName.indexOf(" ") == -1) &&
                                            !sourceArguments.includes(varName)
                                        ) {
                                            if (!lookupList.includes(varName)) {
                                                if (DEBUG)
                                                    console.log("[SigDecode.ForeignIterator] Adding #" + i + " (" + varName + ") to lookup list.");
                                                lookupList.push(varName);
                                            }
                                        }
                                    }

                                    if (DEBUG)
                                        console.log("[SigDecode] lookupList ==", lookupList);

                                    // Iterate the lookup list and search the player JS for the declarations:
                                    var successfulLookups = 0;
                                    var lookupResults = [];
                                    for (var i = 0, j = lookupList.length; i < j; i++) {
                                        // Firstly, objects are searched for. The obfuscator routine is often in
                                        // an object literal, so they're the only thing we're looking for.
                                        var curName = lookupList[i];
                                        var text = playerScript.split("var " + curName + "=")[1];

                                        if (!text)
                                            text = playerScript.split(";" + curName + "=")[1];

                                        if (!text)
                                            text = playerScript.split("\n" + obfuscator + "=")[1];

                                        if (!text)
                                        // Out of possibilities, so just skip this iteration.
                                            continue;

                                        // Parse to the last unclosed "}" character (terminator)
                                        var endIndex = 0;
                                        var depth = 0;

                                        for (var k = 0, l = text.length; k < l; k++) {
                                            if (depth < 0) {
                                                // Parse error, break.
                                                endIndex = -1;
                                                depth = 0;
                                                break;
                                            } else if (text[k] == "{") {
                                                ++depth;
                                            } else if (text[k] == "}") {
                                                if (--depth == 0) {
                                                    endIndex = k + 1;
                                                    break;
                                                }
                                            }
                                        }

                                        // If we had any problems, skip the result.
                                        if (endIndex < 0)
                                            continue;

                                        var resultObj = text.substr(0, endIndex);
                                        var resultText = "var " + curName + "=" + resultObj;
                                        lookupResults.push(resultText);
                                    }

                                    if (DEBUG)
                                        console.log("[SigDecode] lookupResults ==", lookupResults);

                                    if (lookupResults.length == 0) {
                                        result.reason = "Failed to lookup required external functions.";
                                        console.error("[Rehike.SigDecode]" + result.reason);
                                        return result;
                                    }

                                    // Generate the function:
                                    var resultFunctionBody =
                                        lookupResults.join(";") +
                                        ";var decodeSignature = " + sourceDeclaration +
                                        ";return decodeSignature(sourceSignature);"; // sourceSignature declared below.

                                    if (DEBUG)
                                        console.log("[SigDecode] resultFunctionBody ==", resultFunctionBody);

                                    result.cacheParams = {
                                        args: "sourceSignature",
                                        body: resultFunctionBody
                                    };

                                    result.extractCb = new Function(
                                        // Arguments:
                                        result.cacheParams.args,
                                        // Function body:
                                        result.cacheParams.body
                                    );
                                    result.status = "SUCCESS";

                                    return result;
                                }

                                /**
                                 * Extract the "n" parameter decryptor from a given player script.
                                 * 
                                 * Special thanks to Reprety (V3) for providing a reference implementation.
                                 * 
                                 * @argument {string} playerScript A copy of the text content of the latest YouTube player
                                 *                                 binary.
                                 * 
                                 * @returns {
                                 *      {
                                 *          status: string,
                                 *          reason: string, 
                                 *          extractCb: ?function(string),
                                 *          cacheParams: { args: string, body: string }|null
                                 *      }
                                 * }
                                 */
                                function getDecryptorForPlayerN(playerScript) {
                                    var DEBUG = false;

                                    if (DEBUG)
                                        console.log("[NDecode] Using player script:", playerScript);

                                    // Resulting groups:
                                    //   [0]: Entire expression
                                    //   [1]: Assigned variable name.
                                    var BASE_CALL_PATTERN = "([a-zA-Z0-9_$]*?)\\=[a-zA-Z0-9_$]*?\\.get\\(\\\"n\\\"\\)";

                                    // Resulting groups:
                                    //   [0]: Entire expression
                                    //   [1]: Obfuscator function name
                                    //   [2]: Only the array index
                                    var OBFUSCATOR_CALL_PATTERN_TEMPLATE =
                                        "__NAME__=([a-zA-Z0-9_$]*?(\\[[a-zA-Z0-9_$]*\\])?)\\(.*\\)";

                                    // Base result.
                                    var result = {
                                        status: "FAILURE",
                                        reason: "No reason provided.",
                                        extractCb: null,
                                        cacheParams: null
                                    };

                                    var declarationMatches = playerScript.match(new RegExp(BASE_CALL_PATTERN));

                                    if (DEBUG)
                                        console.log("[NDecode] declarationMatches ==", declarationMatches);

                                    if (!declarationMatches) {
                                        result.reason = "Failed to extract decode expression.";
                                        console.error("[Rehike.NDecode]" + result.reason);
                                        return result;
                                    }

                                    var declarationExpression = declarationMatches[0];
                                    var declarationVarName = declarationMatches[1];

                                    // The next use of the declaration variable should be to another
                                    // function. This can become a bit of a mess.
                                    var searchIndex = declarationMatches.index;
                                    var subsequentText = playerScript.slice(searchIndex);

                                    var obfuscatorCallPattern =
                                        OBFUSCATOR_CALL_PATTERN_TEMPLATE.replace("__NAME__", declarationVarName);

                                    var obfuscatorCallMatches = subsequentText.match(new RegExp(obfuscatorCallPattern));
                                    if (DEBUG)
                                        console.log("[NDecode] obfuscatorCallMatches ==", obfuscatorCallMatches);
                                    var obfuscatorFnName = obfuscatorCallMatches[1];

                                    var obfuscatorFnNameSymbol = obfuscatorFnName.split("[")[0];

                                    var obfuscatorFnText = null;
                                    var obfuscatorArrayText = null;
                                    var lookupName = obfuscatorFnName;

                                    if (obfuscatorFnNameSymbol != obfuscatorFnName) {
                                        // The obfuscator is referenced through an array, so we need to do some
                                        // additional work.
                                        obfuscatorArrayText = playerScript.slice(
                                            playerScript.indexOf("var " + obfuscatorFnNameSymbol + "=")
                                        );
                                        obfuscatorArrayText = obfuscatorArrayText.slice(
                                            0,
                                            obfuscatorArrayText.indexOf("]") + 2
                                        );

                                        if (DEBUG)
                                            console.log("[NDecode] (mid) obfuscatorFnNameSymbol ==", obfuscatorFnNameSymbol);

                                        if (DEBUG)
                                            console.log("[NDecode] (mid) obfuscatorArrayText ==", obfuscatorArrayText);

                                        // Set lookupName to the content between the array tokens:
                                        lookupName = obfuscatorArrayText.split("[")[1].split("]")[0];
                                    }

                                    obfuscatorFnText = playerScript.slice(playerScript.indexOf(lookupName + "="));
                                    if (DEBUG)
                                        console.log("[NDecode] obfuscatorFnText ==", obfuscatorFnText);
                                    var flow = [];
                                    var shouldContinue = true;
                                    var parseError = false;
                                    var i = 0;

                                    while (typeof obfuscatorFnText[i] == "string" && shouldContinue) {
                                        var cur = obfuscatorFnText[i];
                                        switch (cur) {
                                            case "'":
                                                if (flow[flow.length - 1] == "'") {
                                                    flow.pop();
                                                    break;
                                                }
                                            case "\"":
                                                if (flow[flow.length - 1] == "\"") {
                                                    flow.pop();
                                                    break;
                                                }
                                            case "`":
                                                if (flow[flow.length - 1] == "`") {
                                                    flow.pop();
                                                    break;
                                                }
                                            case "{":
                                            case "[":
                                                flow.push(cur);
                                                break;
                                            case "]":
                                                if (flow[flow.length - 1] == "[") {
                                                    flow.pop();
                                                } else if (!flow.length) {
                                                    console.error(
                                                        "[Rehike.NDecode.ParseDefinition] Parse error at \"" +
                                                        cur + "\" at index " + i + ". Used to terminate " + flow[flow.length - 1]
                                                    );
                                                    shouldContinue = false;
                                                    parseError = true;
                                                }
                                                break;
                                            case "}":
                                                if (flow[flow.length - 1] == "{") {
                                                    flow.pop();
                                                } else if (!flow.length) {
                                                    console.error(
                                                        "[Rehike.NDecode.ParseDefinition] Parse error at \"" +
                                                        cur + "\" at index " + i + ". Used to terminate " + flow[flow.length - 1]
                                                    );
                                                    shouldContinue = false;
                                                    parseError = true;
                                                }
                                                break;
                                        }
                                        i++;
                                    }

                                    if (i && parseError) {
                                        console.error(
                                            "[Rehike.NDecode.ParseDefinition] Parse error occurred at: " +
                                            obfuscatorFnText.substr(0, i + 1)
                                        );

                                        result.reason = "Parse error at " + obfuscatorFnText.substr(0, i + 1);
                                        return result;
                                    }

                                    if (obfuscatorFnText.indexOf("};]();/") > -1) {
                                        // Honestly, I don't understand this part one bit, so I just copied
                                        // the implementation from Reprety. Parse error correction?
                                        var obfBits = obfuscatorFnText.split("};]();/");
                                        var obfEnd = obfBits[1].slice(0, obfBits[1].search("\\}\\;") + 2);
                                        var obfNew = obfBits[0] + "};]();/" + obfEnd;
                                        obfuscatorFnText = obfNew;
                                    } else {
                                        obfuscatorFnText = obfuscatorFnText.slice(
                                            0,
                                            obfuscatorFnText.search("\\}\\;") + 2
                                        );
                                    }

                                    if (DEBUG)
                                        console.log("[NDecode] (final) obfuscatorFnText ==", obfuscatorFnText);

                                    var bakedFunctionString = "";

                                    bakedFunctionString += obfuscatorFnText + ";";

                                    if (obfuscatorArrayText) {
                                        bakedFunctionString += obfuscatorArrayText + ";";
                                    }

                                    bakedFunctionString += "return " + obfuscatorFnName + "(encryptedN);";

                                    if (DEBUG)
                                        console.log("[NDecode] bakedFunctionString ==", bakedFunctionString);

                                    result.cacheParams = {
                                        args: "encryptedN",
                                        body: bakedFunctionString
                                    };

                                    var bakedFunction = new Function(
                                        // Arguments:
                                        result.cacheParams.args,
                                        // Function body:
                                        result.cacheParams.body
                                    );

                                    result.status = "SUCCESS";
                                    result.extractCb = bakedFunction;

                                    return result;
                                }
                                if (format.signatureCipher) {
                                    const startIndex = format.signatureCipher.indexOf('s=') + 2;
                                    const endIndex = format.signatureCipher.indexOf('&', startIndex);

                                    // Extract the substring between 's=' and '&'
                                    const encodedSignature = format.signatureCipher.substring(startIndex, endIndex);

                                    // Find the index of 'url='
                                    const urlIndex = format.signatureCipher.indexOf('url=');

                                    // Extract the substring after 'url='
                                    const encodedUrl = format.signatureCipher.substring(urlIndex + 4);
                                    const decodedUrl = decodeURIComponent(encodedUrl)
                                        // Find the index of 'n='
                                    const nIndex = decodedUrl.indexOf('&n=');

                                    // Extract everything after '&n=' up to the next '&'
                                    const nParamValue = nIndex !== -1 ? decodedUrl.substring(nIndex + 3, decodedUrl.indexOf('&', nIndex + 3)) : null;

                                    var decodingsigfunction = getDecryptorForPlayerSig(playerScript)
                                    var decodedSignature = decodingsigfunction.extractCb(encodedSignature)
                                    var decodingNfunction = getDecryptorForPlayerN(playerScript)
                                    var decodedN = decodingNfunction.extractCb(nParamValue)
                                        // Replace 'n' parameter with decodedN in decodedUrl and add '&alr=yes&sig=' at the end
                                    const modifiedDecodedUrl = decodedUrl.replace(`&n=${nParamValue}`, `&n=${decodedN}`) + '&alr=yes&sig=' + decodedSignature;
                                    console.log(modifiedDecodedUrl)
                                    return {
                                        encodedSignature,
                                        encodedUrl,
                                        decodedUrl,
                                        nParamValue,
                                        decodedSignature,
                                        decodedN,
                                        modifiedDecodedUrl
                                    };


                                } else if (format.url) {
                                    const encodedUrl = format.url
                                    const nIndex = encodedUrl.indexOf('&n=');

                                    // Extract everything after '&n=' up to the next '&'
                                    const nParamValue = nIndex !== -1 ? encodedUrl.substring(nIndex + 3, encodedUrl.indexOf('&', nIndex + 3)) : null;
                                    var decodingNfunction = getDecryptorForPlayerN(playerScript)
                                    var decodedN = decodingNfunction.extractCb(nParamValue)
                                    const decodedUrl = encodedUrl.replace(`&n=${nParamValue}`, `&n=${decodedN}`);
                                    return {
                                        encodedUrl,
                                        decodedUrl,
                                        nParamValue,
                                        decodedN,
                                    };

                                }
                            }
                            const url = 'https://www.youtube.com/youtubei/v1/player?key=AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8&prettyPrint=false'; // Replace this with the actual URL you want to fetch

                            const payload = {
                                "context": {
                                    'client': {
                                        'clientName': '1',
                                        'clientVersion': '2.20231212'
                                    }
                                },
                                "videoId": video_id,
                                'playbackContext': {
                                    "contentPlaybackContext": {
                                        "currentUrl": "/watch?v=" + video_id + "&pp=ygUWYW50b25pbyB2aXZhbGRpIHdpbnRlcg%3D%3D",
                                        "vis": 0,
                                        "splay": false,
                                        "autoCaptionsDefaultOn": false,
                                        "autonavState": "STATE_NONE",
                                        "html5Preference": "HTML5_PREF_WANTS",
                                        "signatureTimestamp": 19732,
                                        "referer": "https://www.youtube.com/watch?v=" + video_id,
                                        "lactMilliseconds": "-1",
                                        "watchAmbientModeContext": {
                                            "hasShownAmbientMode": true,
                                            "hasToggledOffAmbientMode": true
                                        }
                                    }
                                },
                                'racyCheckOk': false,
                                'contentCheckOk': false
                            }


                            let headers = {}

                            fetch(url, {
                                    method: 'POST',
                                    headers: headers,
                                    mode: 'no-cors',
                                    body: JSON.stringify(payload)
                                })
                                .then((response) => response.json())
                                .then((data) => {
                                    console.log(data)
                                    var format = CreateUrl(data.streamingData.formats[0])
                                    console.log(format)
                                })
                        });
                } else {
                    console.log('The expire timestamp is not in the future.');
                }
            } else {
                console.log('No expire timestamp parameter found in the URL.');
            }</script>
